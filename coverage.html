
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>generator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/EffectiveSloth/flux-app-generator/internal/generator/generator.go (79.5%)</option>
				
				<option value="file1">github.com/EffectiveSloth/flux-app-generator/internal/helm/chart_downloader.go (79.5%)</option>
				
				<option value="file2">github.com/EffectiveSloth/flux-app-generator/internal/helm/version_fetcher.go (87.0%)</option>
				
				<option value="file3">github.com/EffectiveSloth/flux-app-generator/internal/plugins/externalsecret.go (100.0%)</option>
				
				<option value="file4">github.com/EffectiveSloth/flux-app-generator/internal/plugins/imageupdate.go (52.7%)</option>
				
				<option value="file5">github.com/EffectiveSloth/flux-app-generator/internal/plugins/registry.go (93.1%)</option>
				
				<option value="file6">github.com/EffectiveSloth/flux-app-generator/internal/plugins/types.go (89.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package generator

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"

        "github.com/EffectiveSloth/flux-app-generator/internal/plugins"
        "github.com/EffectiveSloth/flux-app-generator/internal/types"
)

// Import embedded templates from main package.
var (
        HelmRepositoryTemplate string
        HelmReleaseTemplate    string
        HelmValuesTemplate     string
        KustomizationTemplate  string
)

func generateFromTemplateString(templateStr, outputPath string, data interface{}) error <span class="cov8" title="1">{
        tmpl, err := template.New("template").Parse(templateStr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse template: %w", err)
        }</span>

        <span class="cov8" title="1">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create %s: %w", outputPath, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log the error but don't return it as the main operation succeeded
                        fmt.Printf("Warning: failed to close file %s: %v\n", outputPath, closeErr)
                }</span>
        }()

        <span class="cov8" title="1">err = tmpl.Execute(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure file ends with a newline
        <span class="cov8" title="1">_, err = file.WriteString("\n")
        return err</span>
}

func generateHelmRepository(config *types.AppConfig, appDir string) error <span class="cov8" title="1">{
        return generateFromTemplateString(
                HelmRepositoryTemplate,
                filepath.Join(appDir, "dependencies", "helm-repository.yaml"),
                config,
        )
}</span>

func generateHelmRelease(config *types.AppConfig, appDir string) error <span class="cov8" title="1">{
        return generateFromTemplateString(
                HelmReleaseTemplate,
                filepath.Join(appDir, "release", "helm-release.yaml"),
                config,
        )
}</span>

func generateHelmValues(config *types.AppConfig, appDir string) error <span class="cov8" title="1">{
        outputPath := filepath.Join(appDir, "release", "helm-values.yaml")
        if raw, ok := config.Values["__raw_yaml__"]; ok </span><span class="cov0" title="0">{
                // Write raw YAML directly, ensuring it ends with a newline
                content := raw.(string)
                if content != "" &amp;&amp; content[len(content)-1] != '\n' </span><span class="cov0" title="0">{
                        content += "\n"
                }</span>
                <span class="cov0" title="0">return os.WriteFile(outputPath, []byte(content), 0600)</span>
        }
        // Create an empty file with just a newline
        <span class="cov8" title="1">return os.WriteFile(outputPath, []byte("\n"), 0600)</span>
}

func generateKustomization(config *types.AppConfig, appDir string) error <span class="cov8" title="1">{
        return generateFromTemplateString(
                KustomizationTemplate,
                filepath.Join(appDir, "kustomization.yaml"),
                config,
        )
}</span>

// GenerateFluxStructure is the main entrypoint for generating the Flux structure.
func GenerateFluxStructure(config *types.AppConfig) error <span class="cov8" title="1">{
        // Create app directory
        appDir := config.AppName
        if err := os.MkdirAll(appDir, 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create app directory %s: %w", appDir, err)
        }</span>

        // Create subdirectories
        <span class="cov8" title="1">dirs := []string{filepath.Join(appDir, "dependencies"), filepath.Join(appDir, "release")}
        for _, dir := range dirs </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }

        <span class="cov8" title="1">if err := generateHelmRepository(config, appDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := generateHelmRelease(config, appDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := generateHelmValues(config, appDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate plugin files first
        <span class="cov8" title="1">pluginFiles, err := generatePluginFiles(config, appDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">config.PluginFiles = pluginFiles

        // Generate kustomization.yaml after plugin files are generated
        if err := generateKustomization(config, appDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Printf("\n‚úÖ Generated Flux structure for '%s' in namespace '%s'\n", config.AppName, config.Namespace)
        fmt.Printf("üìÅ Files created in directory: %s/\n", appDir)

        // Print plugin summary if any plugins were generated
        if len(config.Plugins) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("üîå Generated %d plugin file(s):\n", len(config.Plugins))
                for _, pluginConfig := range config.Plugins </span><span class="cov8" title="1">{
                        fmt.Printf("   - %s\n", pluginConfig.PluginName)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generatePluginFiles generates files for all configured plugins and returns their paths.
func generatePluginFiles(config *types.AppConfig, appDir string) ([]string, error) <span class="cov8" title="1">{
        if len(config.Plugins) == 0 </span><span class="cov8" title="1">{
                return nil, nil // No plugins to generate
        }</span>

        // Create plugin registry to access plugin definitions
        <span class="cov8" title="1">registry := plugins.NewRegistry()
        var pluginFiles []string

        for _, pluginConfig := range config.Plugins </span><span class="cov8" title="1">{
                plugin, exists := registry.Get(pluginConfig.PluginName)
                if !exists </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("plugin '%s' not found in registry", pluginConfig.PluginName)
                }</span>

                // Validate plugin configuration
                <span class="cov8" title="1">if err := plugin.Validate(pluginConfig.Values); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("validation failed for plugin '%s': %w", pluginConfig.PluginName, err)
                }</span>

                // Special handling for imageupdate plugin which generates multiple files
                <span class="cov8" title="1">if pluginConfig.PluginName == "imageupdate" </span><span class="cov8" title="1">{
                        // Generate the plugin files
                        if err := plugin.GenerateFile(pluginConfig.Values, appDir, config.Namespace); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to generate file for plugin '%s': %w", pluginConfig.PluginName, err)
                        }</span>

                        // Add all three imageupdate files to kustomization
                        <span class="cov8" title="1">imageUpdateFiles := []string{
                                "image-repository.yaml",
                                "image-policy.yaml",
                                "image-update-automation.yaml",
                        }
                        pluginFiles = append(pluginFiles, imageUpdateFiles...)

                        fmt.Printf("‚úÖ Generated %s plugin files\n", pluginConfig.PluginName)
                        continue</span>
                }

                // Regular plugin handling
                // Get the file path that will be generated
                <span class="cov8" title="1">templateData := make(map[string]interface{})
                for k, v := range pluginConfig.Values </span><span class="cov8" title="1">{
                        templateData[k] = v
                }</span>
                <span class="cov8" title="1">templateData["Namespace"] = config.Namespace

                // Parse the file path template to get the actual path
                pathTmpl, err := template.New("filepath").Parse(plugin.FilePath())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse file path template for plugin '%s': %w", pluginConfig.PluginName, err)
                }</span>

                <span class="cov8" title="1">var pathBuf strings.Builder
                if err := pathTmpl.Execute(&amp;pathBuf, templateData); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute file path template for plugin '%s': %w", pluginConfig.PluginName, err)
                }</span>

                <span class="cov8" title="1">filePath := pathBuf.String()
                pluginFiles = append(pluginFiles, filePath)

                // Generate the plugin file
                if err := plugin.GenerateFile(pluginConfig.Values, appDir, config.Namespace); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate file for plugin '%s': %w", pluginConfig.PluginName, err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("‚úÖ Generated %s plugin file\n", pluginConfig.PluginName)</span>
        }

        <span class="cov8" title="1">return pluginFiles, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package helm

import (
        "archive/tar"
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "net/http"
        "strings"
)

// DownloadAndExtractValuesYAML downloads the chart tarball and extracts values.yaml as a string.
func DownloadAndExtractValuesYAML(repoURL, chartName, chartVersion string) (string, error) <span class="cov8" title="1">{
        idx, err := fetchIndexYAML(repoURL)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">chartEntries, ok := idx.Entries[chartName]
        if !ok </span><span class="cov8" title="1">{
                return "", fmt.Errorf("chart '%s' not found in repository", chartName)
        }</span>
        <span class="cov8" title="1">var chartURL string
        for _, entry := range chartEntries </span><span class="cov8" title="1">{
                if entry.Version == chartVersion </span><span class="cov8" title="1">{
                        if len(entry.URLs) == 0 </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("no tarball URL found for chart %s version %s", chartName, chartVersion)
                        }</span>
                        <span class="cov8" title="1">chartURL = entry.URLs[0]
                        break</span>
                }
        }
        <span class="cov8" title="1">if chartURL == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("version %s not found for chart %s", chartVersion, chartName)
        }</span>
        <span class="cov8" title="1">resp, err := http.NewRequestWithContext(context.Background(), http.MethodGet, chartURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request for chart: %w", err)
        }</span>
        <span class="cov8" title="1">client := &amp;http.Client{}
        resp2, err := client.Do(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to download chart: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp2.Body.Close()
        if resp2.StatusCode != 200 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to download chart: status %d", resp2.StatusCode)
        }</span>
        <span class="cov8" title="1">gzr, err := gzip.NewReader(resp2.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create gzip reader: %w", err)
        }</span>
        <span class="cov8" title="1">tr := tar.NewReader(gzr)
        for </span><span class="cov8" title="1">{
                hdr, err := tr.Next()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if strings.HasSuffix(hdr.Name, "values.yaml") </span><span class="cov8" title="1">{
                        data, err := io.ReadAll(tr)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to read values.yaml: %w", err)
                        }</span>
                        <span class="cov8" title="1">return string(data), nil</span>
                }
        }
        <span class="cov0" title="0">return "", fmt.Errorf("values.yaml not found in chart")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package helm

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "sort"

        "gopkg.in/yaml.v3"
)

type IndexYAML struct {
        Entries map[string][]struct {
                Version     string   `yaml:"version"`
                AppVersion  string   `yaml:"appVersion"`
                Description string   `yaml:"description"`
                URLs        []string `yaml:"urls"`
        } `yaml:"entries"`
}

// ChartVersion represents a chart version with metadata.
type ChartVersion struct {
        ChartVersion  string
        AppVersion    string
        Description   string
        DisplayString string
}

type fetchIndexYAMLFunc func(repoURL string) (*IndexYAML, error)

// VersionFetcher handles fetching chart versions from Helm repositories.
type VersionFetcher struct {
        fetchIndex fetchIndexYAMLFunc
}

// NewVersionFetcher creates a new version fetcher.
func NewVersionFetcher() *VersionFetcher <span class="cov8" title="1">{
        return &amp;VersionFetcher{fetchIndex: fetchIndexYAML}
}</span>

// NewMockVersionFetcher creates a VersionFetcher with a custom fetchIndex function (for testing).
func NewMockVersionFetcher(mock fetchIndexYAMLFunc) *VersionFetcher <span class="cov8" title="1">{
        return &amp;VersionFetcher{fetchIndex: mock}
}</span>

func fetchIndexYAML(repoURL string) (*IndexYAML, error) <span class="cov8" title="1">{
        // Validate the URL to prevent potential security issues.
        parsedURL, err := url.Parse(repoURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid repository URL: %w", err)
        }</span>
        <span class="cov8" title="1">if parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported URL scheme: %s", parsedURL.Scheme)
        }</span>

        <span class="cov8" title="1">indexURL := repoURL
        if indexURL[len(indexURL)-1] != '/' </span><span class="cov8" title="1">{
                indexURL += "/"
        }</span>
        <span class="cov8" title="1">indexURL += "index.yaml"

        ctx := context.Background()
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, indexURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request for index.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">client := &amp;http.Client{}
        resp, err := client.Do(req) // #nosec G107
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch index.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log the error but don't return it as the main operation succeeded
                        fmt.Printf("Warning: failed to close response body: %v\n", closeErr)
                }</span>
        }()
        <span class="cov8" title="1">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch index.yaml: status %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read index.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">var idx IndexYAML
        if err := yaml.Unmarshal(body, &amp;idx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse index.yaml: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;idx, nil</span>
}

// ListCharts fetches all chart names and their descriptions from a Helm repository.
func (vf *VersionFetcher) ListCharts(repoURL string) ([]struct{ Name, Description string }, error) <span class="cov8" title="1">{
        idx, err := vf.fetchIndex(repoURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var charts []struct{ Name, Description string }
        for name, entries := range idx.Entries </span><span class="cov8" title="1">{
                desc := ""
                if len(entries) &gt; 0 </span><span class="cov8" title="1">{
                        desc = entries[0].Description
                }</span>
                <span class="cov8" title="1">charts = append(charts, struct{ Name, Description string }{Name: name, Description: desc})</span>
        }
        // Sort charts by name.
        <span class="cov8" title="1">sort.Slice(charts, func(i, j int) bool </span><span class="cov0" title="0">{ return charts[i].Name &lt; charts[j].Name }</span>)
        <span class="cov8" title="1">return charts, nil</span>
}

// FetchChartVersions fetches available versions for a chart from a repository.
func (vf *VersionFetcher) FetchChartVersions(repoURL, chartName string) ([]ChartVersion, error) <span class="cov8" title="1">{
        idx, err := vf.fetchIndex(repoURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">chart, exists := idx.Entries[chartName]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("chart '%s' not found in repository", chartName)
        }</span>
        <span class="cov8" title="1">var versions []ChartVersion
        for _, version := range chart </span><span class="cov8" title="1">{
                if version.Version != "" </span><span class="cov8" title="1">{
                        displayString := fmt.Sprintf("%s\t%s\t%s\t%s", chartName, version.Version, version.AppVersion, version.Description)
                        versions = append(versions, ChartVersion{
                                ChartVersion:  version.Version,
                                AppVersion:    version.AppVersion,
                                Description:   version.Description,
                                DisplayString: displayString,
                        })
                }</span>
        }
        // Sort versions (newest first, lexicographically).
        <span class="cov8" title="1">sort.Slice(versions, func(i, j int) bool </span><span class="cov8" title="1">{
                return versions[i].ChartVersion &gt; versions[j].ChartVersion
        }</span>)
        <span class="cov8" title="1">return versions, nil</span>
}

// FetchLatestVersion fetches the latest version for a chart.
func (vf *VersionFetcher) FetchLatestVersion(repoURL, chartName string) (ChartVersion, error) <span class="cov8" title="1">{
        versions, err := vf.FetchChartVersions(repoURL, chartName)
        if err != nil </span><span class="cov8" title="1">{
                return ChartVersion{}, err
        }</span>
        <span class="cov8" title="1">if len(versions) == 0 </span><span class="cov0" title="0">{
                return ChartVersion{}, fmt.Errorf("no versions found for chart '%s'", chartName)
        }</span>
        <span class="cov8" title="1">return versions[0], nil</span>
}

// ValidateChartExists checks if a chart exists in the repository.
func (vf *VersionFetcher) ValidateChartExists(repoURL, chartName string) error <span class="cov8" title="1">{
        idx, err := vf.fetchIndex(repoURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if _, exists := idx.Entries[chartName]; !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("chart '%s' not found in repository", chartName)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package plugins

// ExternalSecretPlugin creates ExternalSecret resources for Kubernetes.
type ExternalSecretPlugin struct {
        BasePlugin
}

// NewExternalSecretPlugin creates a new ExternalSecret plugin instance.
func NewExternalSecretPlugin() *ExternalSecretPlugin <span class="cov8" title="1">{
        variables := []Variable{
                {
                        Name:        "name",
                        Type:        VariableTypeText,
                        Description: "Name for the ExternalSecret resource",
                        Required:    true,
                },
                {
                        Name:        "secret_store_type",
                        Type:        VariableTypeSelect,
                        Description: "Type of secret store to reference",
                        Required:    true,
                        Default:     "ClusterSecretStore",
                        Options: []Option{
                                {Label: "Cluster Secret Store", Value: "ClusterSecretStore"},
                                {Label: "Secret Store", Value: "SecretStore"},
                        },
                },
                {
                        Name:        "secret_store_name",
                        Type:        VariableTypeText,
                        Description: "Name of the secret store resource",
                        Required:    true,
                },
                {
                        Name:        "secret_key",
                        Type:        VariableTypeText,
                        Description: "Key name in the external secret store",
                        Required:    true,
                },
                {
                        Name:        "target_secret_name",
                        Type:        VariableTypeText,
                        Description: "Name of the Kubernetes secret to create",
                        Required:    true,
                },
                {
                        Name:        "refresh_interval",
                        Type:        VariableTypeSelect,
                        Description: "How often to refresh the secret",
                        Required:    false,
                        Default:     "60m",
                        Options: []Option{
                                {Label: "15 minutes", Value: "15m"},
                                {Label: "30 minutes", Value: "30m"},
                                {Label: "1 hour", Value: "60m"},
                                {Label: "2 hours", Value: "120m"},
                                {Label: "6 hours", Value: "6h"},
                                {Label: "12 hours", Value: "12h"},
                                {Label: "24 hours", Value: "24h"},
                        },
                },
        }

        template := `apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: {{.name}}
  namespace: {{.Namespace}}
spec:
  secretStoreRef:
    kind: {{.secret_store_type}}
    name: {{.secret_store_name}}
  dataFrom:
    - extract:
        key: {{.secret_key}}
  refreshInterval: {{.refresh_interval}}
  target:
    creationPolicy: Owner
    name: {{.target_secret_name}}`

        filePath := "dependencies/external-secret-{{.target_secret_name}}.yaml"

        return &amp;ExternalSecretPlugin{
                BasePlugin: BasePlugin{
                        name:        "externalsecret",
                        description: "Generates ExternalSecret resources for managing secrets from external secret stores",
                        variables:   variables,
                        template:    template,
                        filePath:    filePath,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package plugins

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "text/template"

        "github.com/charmbracelet/huh"
)

const (
        // Policy type constants.
        PolicyTypeSemver    = "semver"
        PolicyTypeTimestamp = "timestamp"
        PolicyTypeNumerical = "numerical"

        // Default values.
        DefaultFluxNamespace = "flux-system"
)

// ImageUpdatePlugin creates Flux image update automation resources.
type ImageUpdatePlugin struct {
        BasePlugin
}

// Ensure ImageUpdatePlugin implements CustomConfigPlugin.
var _ CustomConfigPlugin = (*ImageUpdatePlugin)(nil)

// ImageRepository represents a single image repository configuration.
type ImageRepository struct {
        Name      string `json:"name" yaml:"name"`
        Image     string `json:"image" yaml:"image"`
        Interval  string `json:"interval" yaml:"interval"`
        SecretRef string `json:"secretRef,omitempty" yaml:"secretRef,omitempty"`
}

// ImagePolicy represents a single image policy configuration.
type ImagePolicy struct {
        Name       string `json:"name" yaml:"name"`
        Repository string `json:"repository" yaml:"repository"`
        PolicyType string `json:"policyType" yaml:"policyType"`
        Range      string `json:"range,omitempty" yaml:"range,omitempty"`
        Pattern    string `json:"pattern,omitempty" yaml:"pattern,omitempty"`
        Extract    string `json:"extract,omitempty" yaml:"extract,omitempty"`
        Order      string `json:"order,omitempty" yaml:"order,omitempty"`
}

// NewImageUpdatePlugin creates a new image update automation plugin instance.
func NewImageUpdatePlugin() *ImageUpdatePlugin <span class="cov8" title="1">{
        variables := []Variable{
                {
                        Name:        "automation_name",
                        Type:        VariableTypeText,
                        Description: "Name for the ImageUpdateAutomation resource",
                        Required:    true,
                },
        }

        // This plugin will generate multiple files directly in the main directory
        filePath := "image-update-automation.yaml"

        return &amp;ImageUpdatePlugin{
                BasePlugin: BasePlugin{
                        name:        "imageupdate",
                        description: "Generates Flux image update automation resources for automatic container image updates",
                        variables:   variables,
                        template:    "", // We'll override GenerateFile method
                        filePath:    filePath,
                },
        }
}</span>

// Validate performs validation specific to the image update plugin.
func (p *ImageUpdatePlugin) Validate(values map[string]interface{}) error <span class="cov8" title="1">{
        // First, perform base validation
        if err := p.BasePlugin.Validate(values); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate image_repositories JSON
        <span class="cov8" title="1">if err := p.validateImageRepositories(values); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate image_policies JSON
        <span class="cov8" title="1">if err := p.validateImagePolicies(values); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateImageRepositories validates the image_repositories JSON field.
func (p *ImageUpdatePlugin) validateImageRepositories(values map[string]interface{}) error <span class="cov8" title="1">{
        return p.validateJSONField(values, "image_repositories", func(data []byte) error </span><span class="cov8" title="1">{
                var repos []ImageRepository
                if err := json.Unmarshal(data, &amp;repos); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">for i, repo := range repos </span><span class="cov8" title="1">{
                        if err := p.validateSingleRepository(repo, i); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

// validateImagePolicies validates the image_policies JSON field.
func (p *ImageUpdatePlugin) validateImagePolicies(values map[string]interface{}) error <span class="cov8" title="1">{
        return p.validateJSONField(values, "image_policies", func(data []byte) error </span><span class="cov8" title="1">{
                var policies []ImagePolicy
                if err := json.Unmarshal(data, &amp;policies); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">for i, policy := range policies </span><span class="cov8" title="1">{
                        if err := p.validateSinglePolicy(&amp;policy, i); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

// validateJSONField provides common JSON field validation logic.
func (p *ImageUpdatePlugin) validateJSONField(values map[string]interface{}, fieldName string, validator func([]byte) error) error <span class="cov8" title="1">{
        data, exists := values[fieldName]
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">dataStr, ok := data.(string)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := validator([]byte(dataStr)); err != nil </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: fieldName,
                        Message:  fmt.Sprintf("invalid JSON format: %v", err),
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateSingleRepository validates a single image repository configuration.
func (p *ImageUpdatePlugin) validateSingleRepository(repo ImageRepository, index int) error <span class="cov8" title="1">{
        if repo.Name == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_repositories",
                        Message:  fmt.Sprintf("repository %d: name is required", index),
                }
        }</span>
        <span class="cov8" title="1">if repo.Image == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_repositories",
                        Message:  fmt.Sprintf("repository %d: image is required", index),
                }
        }</span>
        <span class="cov8" title="1">if repo.Interval == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_repositories",
                        Message:  fmt.Sprintf("repository %d: interval is required", index),
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateSinglePolicy validates a single image policy configuration.
func (p *ImageUpdatePlugin) validateSinglePolicy(policy *ImagePolicy, index int) error <span class="cov8" title="1">{
        if policy.Name == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: name is required", index),
                }
        }</span>
        <span class="cov8" title="1">if policy.Repository == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: repository is required", index),
                }
        }</span>
        <span class="cov8" title="1">if policy.PolicyType == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: policyType is required", index),
                }
        }</span>

        <span class="cov8" title="1">return p.validatePolicyTypeSpecificFields(policy, index)</span>
}

// validatePolicyTypeSpecificFields validates fields specific to each policy type.
func (p *ImageUpdatePlugin) validatePolicyTypeSpecificFields(policy *ImagePolicy, index int) error <span class="cov8" title="1">{
        switch policy.PolicyType </span>{
        case PolicyTypeSemver:<span class="cov8" title="1">
                return p.validateSemverPolicy(policy, index)</span>
        case PolicyTypeNumerical:<span class="cov8" title="1">
                return p.validateNumericalPolicy(policy, index)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateSemverPolicy validates semver-specific policy fields.
func (p *ImageUpdatePlugin) validateSemverPolicy(policy *ImagePolicy, index int) error <span class="cov8" title="1">{
        if policy.Range == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: range is required for semver policy", index),
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateNumericalPolicy validates numerical-specific policy fields.
func (p *ImageUpdatePlugin) validateNumericalPolicy(policy *ImagePolicy, index int) error <span class="cov8" title="1">{
        if policy.Pattern == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: pattern is required for numerical policy", index),
                }
        }</span>
        <span class="cov8" title="1">if policy.Extract == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: extract is required for numerical policy", index),
                }
        }</span>
        <span class="cov8" title="1">if policy.Order == "" </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Variable: "image_policies",
                        Message:  fmt.Sprintf("policy %d: order is required for numerical policy", index),
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CollectCustomConfig handles the multi-step configuration for image update automation.
func (p *ImageUpdatePlugin) CollectCustomConfig(values map[string]interface{}) error <span class="cov0" title="0">{
        // Step 1: Configure ImageRepository
        repo, err := p.configureImageRepository()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure image repository: %w", err)
        }</span>

        // Step 2: Configure ImagePolicy
        <span class="cov0" title="0">policy, err := p.configureImagePolicy(repo.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure image policy: %w", err)
        }</span>

        // Step 3: Configure ImageUpdateAutomation
        <span class="cov0" title="0">automation, err := p.configureImageUpdateAutomation()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to configure image update automation: %w", err)
        }</span>

        // Convert to JSON arrays (single items)
        <span class="cov0" title="0">repos := []ImageRepository{repo}
        policies := []ImagePolicy{policy}

        repoJSON, _ := json.Marshal(repos)
        policyJSON, _ := json.Marshal(policies)

        values["image_repositories"] = string(repoJSON)
        values["image_policies"] = string(policyJSON)

        // Set automation values
        values["git_repository_name"] = automation.GitRepositoryName
        values["git_repository_namespace"] = automation.GitRepositoryNamespace
        values["update_path"] = automation.UpdatePath
        values["git_branch"] = automation.GitBranch
        values["author_name"] = automation.AuthorName
        values["author_email"] = automation.AuthorEmail
        values["automation_interval"] = automation.Interval
        values["update_strategy"] = "Setters"
        values["commit_message_template"] = "chore: update container versions"

        return nil</span>
}

// configureImageRepository handles the first step: ImageRepository configuration.
func (p *ImageUpdatePlugin) configureImageRepository() (ImageRepository, error) <span class="cov0" title="0">{
        var repo ImageRepository

        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewInput().
                                Title("Repository Name").
                                Description("Unique name for this image repository").
                                Value(&amp;repo.Name).
                                Validate(func(s string) error </span><span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("repository name is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewInput().
                                Title("Container Image").
                                Description("Full image name (e.g., nginx, myregistry/myapp)").
                                Value(&amp;repo.Image).
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("image name is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewSelect[string]().
                                Title("Check Interval").
                                Description("How often to check for new image versions").
                                Options(
                                        huh.NewOption("1 hour", "60m"),
                                        huh.NewOption("6 hours", "6h"),
                                        huh.NewOption("12 hours", "12h"),
                                        huh.NewOption("24 hours", "24h"),
                                ).
                                Value(&amp;repo.Interval),

                        huh.NewInput().
                                Title("Secret Reference (Optional)").
                                Description("Name of secret for private registry (leave empty for public)").
                                Value(&amp;repo.SecretRef),
                ).Title("üì¶ Step 1: Configure Image Repository"),
        ).WithTheme(huh.ThemeCharm())

        // Set default
        <span class="cov0" title="0">repo.Interval = "6h"

        return repo, form.Run()</span>
}

// configureImagePolicy handles the second step: ImagePolicy configuration.
func (p *ImageUpdatePlugin) configureImagePolicy(repositoryName string) (ImagePolicy, error) <span class="cov0" title="0">{
        var policy ImagePolicy
        var policyType string

        // Basic policy configuration
        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewInput().
                                Title("Policy Name").
                                Description("Name for this image policy").
                                Value(&amp;policy.Name).
                                Validate(func(s string) error </span><span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("policy name is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewSelect[string]().
                                Title("Version Policy").
                                Description("How should image versions be evaluated?").
                                Options(
                                        huh.NewOption("Semantic Versioning (1.2.3)", PolicyTypeSemver),
                                        huh.NewOption("Timestamp-based (main-abc123-1234567890)", PolicyTypeTimestamp),
                                ).
                                Value(&amp;policyType),
                ).Title("üè∑Ô∏è Step 2: Configure Image Policy"),
        ).WithTheme(huh.ThemeCharm())

        // Set defaults
        <span class="cov0" title="0">policy.Repository = repositoryName
        policyType = PolicyTypeSemver

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return policy, err
        }</span>

        // Configure policy-specific settings
        <span class="cov0" title="0">policy.PolicyType = policyType
        if policyType == PolicyTypeTimestamp </span><span class="cov0" title="0">{
                policy.Pattern = "^main-[a-f0-9]+-(?P&lt;ts&gt;[0-9]+)"
                policy.Extract = "$ts"
                policy.Order = "asc"
                policy.PolicyType = PolicyTypeNumerical
        }</span> else<span class="cov0" title="0"> {
                // Semver policy - ask for range
                var semverRange string
                rangeForm := huh.NewForm(
                        huh.NewGroup(
                                huh.NewSelect[string]().
                                        Title("Version Range").
                                        Description("Which semantic versions should be considered?").
                                        Options(
                                                huh.NewOption("Any version (*)", "*"),
                                                huh.NewOption("Major version (^1.0.0)", "^1.0.0"),
                                                huh.NewOption("Minor version (~1.2.0)", "~1.2.0"),
                                        ).
                                        Value(&amp;semverRange),
                        ).Title("üè∑Ô∏è Semantic Version Range"),
                ).WithTheme(huh.ThemeCharm())

                semverRange = "*"
                if err := rangeForm.Run(); err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">policy.Range = semverRange</span>
        }

        <span class="cov0" title="0">return policy, nil</span>
}

// ImageUpdateAutomationConfig holds the automation configuration.
type ImageUpdateAutomationConfig struct {
        GitRepositoryName      string
        GitRepositoryNamespace string
        UpdatePath             string
        GitBranch              string
        AuthorName             string
        AuthorEmail            string
        Interval               string
}

// configureImageUpdateAutomation handles the third step: ImageUpdateAutomation configuration.
func (p *ImageUpdatePlugin) configureImageUpdateAutomation() (ImageUpdateAutomationConfig, error) <span class="cov0" title="0">{
        var config ImageUpdateAutomationConfig

        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewInput().
                                Title("GitRepository Name").
                                Description("Name of the GitRepository resource to reference").
                                Value(&amp;config.GitRepositoryName).
                                Validate(func(s string) error </span><span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("git repository name is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewInput().
                                Title("GitRepository Namespace").
                                Description("Namespace of the GitRepository resource").
                                Value(&amp;config.GitRepositoryNamespace).
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("git repository namespace is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewInput().
                                Title("Update Path").
                                Description("Path to update in the repository (e.g., ./apps/myapp)").
                                Value(&amp;config.UpdatePath).
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("update path is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewInput().
                                Title("Git Branch").
                                Description("Git branch to push updates to").
                                Value(&amp;config.GitBranch).
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("git branch is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewInput().
                                Title("Author Name").
                                Description("Author name for git commits").
                                Value(&amp;config.AuthorName).
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("author name is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewInput().
                                Title("Author Email").
                                Description("Author email for git commits").
                                Value(&amp;config.AuthorEmail).
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("author email is required")
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),

                        huh.NewSelect[string]().
                                Title("Automation Interval").
                                Description("How often to check for updates").
                                Options(
                                        huh.NewOption("5 minutes", "5m"),
                                        huh.NewOption("10 minutes", "10m"),
                                        huh.NewOption("30 minutes", "30m"),
                                        huh.NewOption("1 hour", "60m"),
                                ).
                                Value(&amp;config.Interval),
                ).Title("‚öôÔ∏è Step 3: Configure Update Automation"),
        ).WithTheme(huh.ThemeCharm())

        // Set defaults
        <span class="cov0" title="0">config.GitRepositoryName = DefaultFluxNamespace
        config.GitRepositoryNamespace = DefaultFluxNamespace
        config.GitBranch = "main"
        config.Interval = "10m"

        return config, form.Run()</span>
}

// GenerateFile creates the three image update automation files directly in the main directory.
func (p *ImageUpdatePlugin) GenerateFile(values map[string]interface{}, appDir, namespace string) error <span class="cov8" title="1">{
        // Parse image repositories and policies from JSON
        var imageRepositories []ImageRepository
        var imagePolicies []ImagePolicy

        if repoData, exists := values["image_repositories"]; exists </span><span class="cov8" title="1">{
                if repoStr, ok := repoData.(string); ok </span><span class="cov8" title="1">{
                        if err := json.Unmarshal([]byte(repoStr), &amp;imageRepositories); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to parse image repositories: %v", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if policyData, exists := values["image_policies"]; exists </span><span class="cov8" title="1">{
                if policyStr, ok := policyData.(string); ok </span><span class="cov8" title="1">{
                        if err := json.Unmarshal([]byte(policyStr), &amp;imagePolicies); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to parse image policies: %v", err)
                        }</span>
                }
        }

        // Create template data
        <span class="cov8" title="1">templateData := make(map[string]interface{})
        for k, v := range values </span><span class="cov8" title="1">{
                templateData[k] = v
        }</span>
        <span class="cov8" title="1">templateData["Namespace"] = namespace
        templateData["ImageRepositories"] = imageRepositories
        templateData["ImagePolicies"] = imagePolicies

        // Generate the three files directly in the main directory
        files := map[string]string{
                "image-repository.yaml": `{{- range .ImageRepositories }}
---
apiVersion: image.toolkit.fluxcd.io/v1beta2
kind: ImageRepository
metadata:
  name: {{.Name}}
spec:
  image: {{.Image}}
  interval: {{.Interval}}{{- if .SecretRef }}
  secretRef:
    name: {{.SecretRef}}{{- end }}
{{- end }}`,
                "image-policy.yaml": `{{- range .ImagePolicies }}
---
apiVersion: image.toolkit.fluxcd.io/v1beta2
kind: ImagePolicy
metadata:
  name: {{.Name}}
spec:
  imageRepositoryRef:
    name: {{.Repository}}{{- if eq .PolicyType "semver" }}
  policy:
    semver:
      range: '{{.Range}}'{{- else if eq .PolicyType "numerical" }}
  filterTags:
    pattern: '{{.Pattern}}'
    extract: '{{.Extract}}'
  policy:
    numerical:
      order: {{.Order}}{{- end }}
{{- end }}`,
                "image-update-automation.yaml": `---
apiVersion: image.toolkit.fluxcd.io/v1beta1
kind: ImageUpdateAutomation
metadata:
  name: {{.automation_name}}
  namespace: {{.Namespace}}
spec:
  interval: {{.automation_interval}}
  sourceRef:
    kind: GitRepository
    name: {{.git_repository_name}}
    namespace: {{.git_repository_namespace}}
  git:
    commit:
      author:
        email: {{.author_email}}
        name: {{.author_name}}
      messageTemplate: "{{.commit_message_template}}"
    push:
      branch: {{.git_branch}}
  update:
    path: {{.update_path}}
    strategy: {{.update_strategy}}`,
        }

        for filename, templateStr := range files </span><span class="cov8" title="1">{
                outputPath := filepath.Join(appDir, filename)
                if err := p.generateSingleFile(templateStr, outputPath, templateData); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to generate %s: %v", filename, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateSingleFile is a helper method to generate a single file from a template.
func (p *ImageUpdatePlugin) generateSingleFile(templateStr, outputPath string, data interface{}) error <span class="cov8" title="1">{
        tmpl, err := template.New("template").Parse(templateStr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse template: %w", err)
        }</span>

        <span class="cov8" title="1">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create %s: %w", outputPath, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close file %s: %v\n", outputPath, closeErr)
                }</span>
        }()

        <span class="cov8" title="1">if err := tmpl.Execute(file, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        // Ensure file ends with a newline
        <span class="cov8" title="1">if _, err := file.WriteString("\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write newline: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package plugins

import (
        "fmt"
)

// Registry manages all available plugins.
type Registry struct {
        plugins map[string]Plugin
}

// NewRegistry creates a new plugin registry with all built-in plugins registered.
func NewRegistry() *Registry <span class="cov8" title="1">{
        registry := &amp;Registry{
                plugins: make(map[string]Plugin),
        }

        // Register built-in plugins
        registry.registerBuiltinPlugins()

        return registry
}</span>

// registerBuiltinPlugins registers all built-in plugins.
func (r *Registry) registerBuiltinPlugins() <span class="cov8" title="1">{
        // Register the ExternalSecret plugin
        if err := r.Register(NewExternalSecretPlugin()); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to register built-in externalsecret plugin: %v", err))</span>
        }

        // Register the ImageUpdate plugin
        <span class="cov8" title="1">if err := r.Register(NewImageUpdatePlugin()); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to register built-in imageupdate plugin: %v", err))</span>
        }
}

// Register adds a plugin to the registry.
func (r *Registry) Register(plugin Plugin) error <span class="cov8" title="1">{
        if plugin == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot register nil plugin")
        }</span>

        <span class="cov8" title="1">name := plugin.Name()
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("plugin name cannot be empty")
        }</span>

        <span class="cov8" title="1">if _, exists := r.plugins[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("plugin with name '%s' is already registered", name)
        }</span>

        <span class="cov8" title="1">r.plugins[name] = plugin
        return nil</span>
}

// Get retrieves a plugin by name.
func (r *Registry) Get(name string) (Plugin, bool) <span class="cov8" title="1">{
        plugin, exists := r.plugins[name]
        return plugin, exists
}</span>

// List returns all registered plugins.
func (r *Registry) List() []Plugin <span class="cov8" title="1">{
        plugins := make([]Plugin, 0, len(r.plugins))
        for _, plugin := range r.plugins </span><span class="cov8" title="1">{
                plugins = append(plugins, plugin)
        }</span>
        <span class="cov8" title="1">return plugins</span>
}

// GetNames returns the names of all registered plugins.
func (r *Registry) GetNames() []string <span class="cov8" title="1">{
        names := make([]string, 0, len(r.plugins))
        for name := range r.plugins </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// Count returns the number of registered plugins.
func (r *Registry) Count() int <span class="cov8" title="1">{
        return len(r.plugins)
}</span>

// Exists checks if a plugin with the given name is registered.
func (r *Registry) Exists(name string) bool <span class="cov8" title="1">{
        _, exists := r.plugins[name]
        return exists
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package plugins

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"
)

// VariableType represents the different types of input variables a plugin can have.
type VariableType string

const (
        VariableTypeText     VariableType = "text"
        VariableTypeBool     VariableType = "bool"
        VariableTypeSelect   VariableType = "select"
        VariableTypeCheckbox VariableType = "checkbox"
)

// Variable defines a configurable input for a plugin.
type Variable struct {
        Name        string       `json:"name" yaml:"name"`
        Type        VariableType `json:"type" yaml:"type"`
        Description string       `json:"description" yaml:"description"`
        Required    bool         `json:"required" yaml:"required"`
        Default     interface{}  `json:"default,omitempty" yaml:"default,omitempty"`
        Options     []Option     `json:"options,omitempty" yaml:"options,omitempty"` // For select type
}

// Option represents a choice for select-type variables.
type Option struct {
        Label string      `json:"label" yaml:"label"`
        Value interface{} `json:"value" yaml:"value"`
}

// PluginConfig holds the runtime configuration for a plugin instance.
type PluginConfig struct {
        PluginName string                 `json:"plugin_name" yaml:"plugin_name"`
        Values     map[string]interface{} `json:"values" yaml:"values"`
}

// Plugin defines the interface that all plugins must implement.
type Plugin interface {
        // Name returns the unique name/identifier of the plugin.
        Name() string

        // Description returns a human-readable description of the plugin.
        Description() string

        // Variables returns the list of configurable variables for this plugin.
        Variables() []Variable

        // Template returns the YAML template string for generating the output file.
        Template() string

        // FilePath returns the template for the output file path (can include variables).
        FilePath() string

        // Validate checks if the provided values are valid for this plugin.
        Validate(values map[string]interface{}) error

        // GenerateFile creates the output file using the template and values.
        GenerateFile(values map[string]interface{}, appDir, namespace string) error
}

// CustomConfigPlugin defines an interface for plugins that need custom configuration collection.
// This allows plugins to implement their own multi-screen or advanced configuration logic.
type CustomConfigPlugin interface {
        Plugin

        // CollectCustomConfig handles custom configuration collection beyond standard variables.
        // This method is called after standard variables are collected.
        // It should modify the values map to include any additional configuration.
        CollectCustomConfig(values map[string]interface{}) error
}

// BasePlugin provides common functionality for plugins.
type BasePlugin struct {
        name        string
        description string
        variables   []Variable
        template    string
        filePath    string
}

// Name returns the plugin name.
func (p *BasePlugin) Name() string <span class="cov8" title="1">{
        return p.name
}</span>

// Description returns the plugin description.
func (p *BasePlugin) Description() string <span class="cov8" title="1">{
        return p.description
}</span>

// Variables returns the plugin variables.
func (p *BasePlugin) Variables() []Variable <span class="cov8" title="1">{
        return p.variables
}</span>

// Template returns the plugin template.
func (p *BasePlugin) Template() string <span class="cov8" title="1">{
        return p.template
}</span>

// FilePath returns the plugin file path template.
func (p *BasePlugin) FilePath() string <span class="cov8" title="1">{
        return p.filePath
}</span>

// Validate performs basic validation on the provided values.
func (p *BasePlugin) Validate(values map[string]interface{}) error <span class="cov8" title="1">{
        for _, variable := range p.variables </span><span class="cov8" title="1">{
                if variable.Required </span><span class="cov8" title="1">{
                        if _, exists := values[variable.Name]; !exists </span><span class="cov8" title="1">{
                                return &amp;ValidationError{
                                        Variable: variable.Name,
                                        Message:  "required variable is missing",
                                }
                        }</span>
                }

                // Type-specific validation
                <span class="cov8" title="1">if value, exists := values[variable.Name]; exists &amp;&amp; value != nil </span><span class="cov8" title="1">{
                        if err := p.validateVariableType(&amp;variable, value); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// validateVariableType validates a single variable value against its type.
func (p *BasePlugin) validateVariableType(variable *Variable, value interface{}) error <span class="cov8" title="1">{
        switch variable.Type </span>{
        case VariableTypeBool, VariableTypeCheckbox:<span class="cov8" title="1">
                if _, ok := value.(bool); !ok </span><span class="cov8" title="1">{
                        return &amp;ValidationError{
                                Variable: variable.Name,
                                Message:  "value must be a boolean",
                        }
                }</span>
        case VariableTypeText:<span class="cov8" title="1">
                if _, ok := value.(string); !ok </span><span class="cov8" title="1">{
                        return &amp;ValidationError{
                                Variable: variable.Name,
                                Message:  "value must be a string",
                        }
                }</span>
        case VariableTypeSelect:<span class="cov8" title="1">
                // Check if value is one of the allowed options
                found := false
                for _, option := range variable.Options </span><span class="cov8" title="1">{
                        if option.Value == value </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return &amp;ValidationError{
                                Variable: variable.Name,
                                Message:  "value is not one of the allowed options",
                        }
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GenerateFile creates the output file using the template and values.
func (p *BasePlugin) GenerateFile(values map[string]interface{}, appDir, namespace string) error <span class="cov8" title="1">{
        // Create template data combining values with namespace
        templateData := make(map[string]interface{})
        for k, v := range values </span><span class="cov8" title="1">{
                templateData[k] = v
        }</span>
        <span class="cov8" title="1">templateData["Namespace"] = namespace

        // Parse the file path template
        pathTmpl, err := template.New("filepath").Parse(p.filePath)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;TemplateError{
                        Plugin:  p.name,
                        Type:    "filepath",
                        Message: err.Error(),
                }
        }</span>

        <span class="cov8" title="1">var pathBuf strings.Builder
        if err := pathTmpl.Execute(&amp;pathBuf, templateData); err != nil </span><span class="cov0" title="0">{
                return &amp;TemplateError{
                        Plugin:  p.name,
                        Type:    "filepath",
                        Message: err.Error(),
                }
        }</span>

        <span class="cov8" title="1">outputPath := filepath.Join(appDir, pathBuf.String())

        // Ensure output directory exists
        if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil </span><span class="cov0" title="0">{
                return &amp;FileError{
                        Plugin:    p.name,
                        Operation: "create_directory",
                        Path:      filepath.Dir(outputPath),
                        Message:   err.Error(),
                }
        }</span>

        // Parse and execute the YAML template
        <span class="cov8" title="1">tmpl, err := template.New("plugin").Parse(p.template)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;TemplateError{
                        Plugin:  p.name,
                        Type:    "yaml",
                        Message: err.Error(),
                }
        }</span>

        <span class="cov8" title="1">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;FileError{
                        Plugin:    p.name,
                        Operation: "create_file",
                        Path:      outputPath,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close file %s: %v\n", outputPath, closeErr)
                }</span>
        }()

        <span class="cov8" title="1">if err := tmpl.Execute(file, templateData); err != nil </span><span class="cov0" title="0">{
                return &amp;TemplateError{
                        Plugin:  p.name,
                        Type:    "yaml",
                        Message: err.Error(),
                }
        }</span>

        // Ensure file ends with a newline
        <span class="cov8" title="1">if _, err := file.WriteString("\n"); err != nil </span><span class="cov0" title="0">{
                return &amp;FileError{
                        Plugin:    p.name,
                        Operation: "write_newline",
                        Path:      outputPath,
                        Message:   err.Error(),
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidationError represents a plugin validation error.
type ValidationError struct {
        Variable string
        Message  string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error for variable '%s': %s", e.Variable, e.Message)
}</span>

// TemplateError represents a template processing error.
type TemplateError struct {
        Plugin  string
        Type    string // "yaml" or "filepath"
        Message string
}

func (e *TemplateError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("template error in plugin '%s' (%s): %s", e.Plugin, e.Type, e.Message)
}</span>

// FileError represents a file operation error.
type FileError struct {
        Plugin    string
        Operation string
        Path      string
        Message   string
}

func (e *FileError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("file error in plugin '%s' during %s for path '%s': %s", e.Plugin, e.Operation, e.Path, e.Message)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
