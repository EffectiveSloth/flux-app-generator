package generator

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/EffectiveSloth/flux-app-generator/internal/plugins"
	"github.com/EffectiveSloth/flux-app-generator/internal/types"
)

func TestGenerateFromTemplateString(t *testing.T) {
	// Set up test templates
	HelmRepositoryTemplate = `apiVersion: source.toolkit.fluxcd.io/v1
kind: HelmRepository
metadata:
  name: {{.HelmRepoName}}
  namespace: {{.Namespace}}
spec:
  interval: {{.Interval}}
  url: {{.HelmRepoURL}}`

	HelmReleaseTemplate = `apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: {{.AppName}}
  namespace: {{.Namespace}}
spec:
  interval: {{.Interval}}
  chart:
    spec:
      chart: {{.ChartName}}
      version: '{{.ChartVersion}}'
      sourceRef:
        kind: HelmRepository
        name: {{.HelmRepoName}}
      interval: {{.Interval}}
  valuesFrom:
    - kind: ConfigMap
      name: {{.AppName}}-values
      valuesKey: values.yaml`

	HelmValuesTemplate = `# Helm values for {{.AppName}}
# Generated by flux-app-generator

{{- range $key, $value := .Values }}
{{$key}}: {{$value}}
{{- end }}`

	KustomizationTemplate = `apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - dependencies/helm-repository.yaml
  - release/helm-release.yaml

configMapGenerator:
  - name: {{.AppName}}-values
    files:
      - values.yaml=release/helm-values.yaml
    options:
      disableNameSuffixHash: true`

	tests := []struct {
		name        string
		templateStr string
		data        interface{}
		expectError bool
	}{
		{
			name:        "valid template",
			templateStr: "Hello {{.Name}}!",
			data:        map[string]string{"Name": "World"},
			expectError: false,
		},
		{
			name:        "invalid template",
			templateStr: "Hello {{.Name}!", // Missing closing brace
			data:        map[string]string{"Name": "World"},
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tempDir := t.TempDir()
			outputPath := filepath.Join(tempDir, "test.txt")

			err := generateFromTemplateString(tt.templateStr, outputPath, tt.data)
			if tt.expectError && err == nil {
				t.Errorf("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}

			if !tt.expectError {
				// Check if file was created
				if _, err := os.Stat(outputPath); os.IsNotExist(err) {
					t.Errorf("expected file to be created at %s", outputPath)
				}
			}
		})
	}
}

func TestGenerateHelmRepository(t *testing.T) {
	config := &types.AppConfig{
		HelmRepoName: "test-repo",
		Namespace:    "default",
		Interval:     "5m",
		HelmRepoURL:  "https://example.com/repo",
	}

	tempDir := t.TempDir()
	appDir := filepath.Join(tempDir, "test-app")
	if err := os.MkdirAll(appDir, 0755); err != nil {
		t.Fatalf("failed to create test directory: %v", err)
	}

	// Create the dependencies subdirectory
	depsDir := filepath.Join(appDir, "dependencies")
	if err := os.MkdirAll(depsDir, 0755); err != nil {
		t.Fatalf("failed to create dependencies directory: %v", err)
	}

	err := generateHelmRepository(config, appDir)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Check if file was created
	expectedPath := filepath.Join(appDir, "dependencies", "helm-repository.yaml")
	if _, err := os.Stat(expectedPath); os.IsNotExist(err) {
		t.Errorf("expected file to be created at %s", expectedPath)
	}
}

func TestGenerateHelmRelease(t *testing.T) {
	config := &types.AppConfig{
		AppName:      "test-app",
		Namespace:    "default",
		HelmRepoName: "test-repo",
		ChartName:    "test-chart",
		ChartVersion: "1.0.0",
		Interval:     "5m",
	}

	tempDir := t.TempDir()
	appDir := filepath.Join(tempDir, "test-app")
	if err := os.MkdirAll(appDir, 0755); err != nil {
		t.Fatalf("failed to create test directory: %v", err)
	}

	// Create the release subdirectory
	releaseDir := filepath.Join(appDir, "release")
	if err := os.MkdirAll(releaseDir, 0755); err != nil {
		t.Fatalf("failed to create release directory: %v", err)
	}

	err := generateHelmRelease(config, appDir)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Check if file was created
	expectedPath := filepath.Join(appDir, "release", "helm-release.yaml")
	if _, err := os.Stat(expectedPath); os.IsNotExist(err) {
		t.Errorf("expected file to be created at %s", expectedPath)
	}
}

func TestGenerateHelmValues(t *testing.T) {
	config := &types.AppConfig{
		AppName: "test-app",
		Values: map[string]interface{}{
			"replicaCount": 3,
			"image": map[string]string{
				"repository": "nginx",
				"tag":        "latest",
			},
		},
	}

	tempDir := t.TempDir()
	appDir := filepath.Join(tempDir, "test-app")
	if err := os.MkdirAll(appDir, 0755); err != nil {
		t.Fatalf("failed to create test directory: %v", err)
	}

	// Create the release subdirectory
	releaseDir := filepath.Join(appDir, "release")
	if err := os.MkdirAll(releaseDir, 0755); err != nil {
		t.Fatalf("failed to create release directory: %v", err)
	}

	err := generateHelmValues(config, appDir)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Check if file was created
	expectedPath := filepath.Join(appDir, "release", "helm-values.yaml")
	if _, err := os.Stat(expectedPath); os.IsNotExist(err) {
		t.Errorf("expected file to be created at %s", expectedPath)
	}
}

func TestGenerateKustomization(t *testing.T) {
	config := &types.AppConfig{
		AppName: "test-app",
	}

	tempDir := t.TempDir()
	appDir := filepath.Join(tempDir, "test-app")
	if err := os.MkdirAll(appDir, 0755); err != nil {
		t.Fatalf("failed to create test directory: %v", err)
	}

	err := generateKustomization(config, appDir)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Check if file was created
	expectedPath := filepath.Join(appDir, "kustomization.yaml")
	if _, err := os.Stat(expectedPath); os.IsNotExist(err) {
		t.Errorf("expected file to be created at %s", expectedPath)
	}
}

func TestGenerateFluxStructure(t *testing.T) {
	config := &types.AppConfig{
		AppName:      "test-app",
		Namespace:    "default",
		HelmRepoName: "test-repo",
		HelmRepoURL:  "https://example.com/repo",
		ChartName:    "test-chart",
		ChartVersion: "1.0.0",
		Interval:     "5m",
		Values: map[string]interface{}{
			"replicaCount": 3,
		},
	}

	tempDir := t.TempDir()
	originalWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get current working directory: %v", err)
	}

	// Change to temp directory for test
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("failed to change to temp directory: %v", err)
	}
	defer func() {
		if err := os.Chdir(originalWd); err != nil {
			t.Errorf("failed to restore working directory: %v", err)
		}
	}()

	err = GenerateFluxStructure(config)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Check if all expected files were created
	expectedFiles := []string{
		"test-app/dependencies/helm-repository.yaml",
		"test-app/release/helm-release.yaml",
		"test-app/release/helm-values.yaml",
		"test-app/kustomization.yaml",
	}

	for _, file := range expectedFiles {
		if _, err := os.Stat(file); os.IsNotExist(err) {
			t.Errorf("expected file to be created: %s", file)
		}
	}
}

func TestGenerateFluxStructure_DirectoryCreationError(t *testing.T) {
	config := &types.AppConfig{
		AppName: "", // Empty name should cause directory creation to fail
	}

	err := GenerateFluxStructure(config)
	if err == nil {
		t.Errorf("expected error for empty app name")
	}
}

// Test generatePluginFiles function
func TestGeneratePluginFiles(t *testing.T) {
	tempDir := t.TempDir()
	originalWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get current working directory: %v", err)
	}

	// Change to temp directory for test
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("failed to change to temp directory: %v", err)
	}
	defer func() {
		if err := os.Chdir(originalWd); err != nil {
			t.Errorf("failed to restore working directory: %v", err)
		}
	}()

	tests := []struct {
		name          string
		config        *types.AppConfig
		expectError   bool
		expectedFiles []string
	}{
		{
			name: "no plugins",
			config: &types.AppConfig{
				AppName:   "test-app",
				Namespace: "default",
				Plugins:   []plugins.PluginConfig{},
			},
			expectError:   false,
			expectedFiles: nil,
		},
		{
			name: "imageupdate plugin",
			config: &types.AppConfig{
				AppName:   "test-app",
				Namespace: "default",
				Plugins: []plugins.PluginConfig{
					{
						PluginName: "imageupdate",
						Values: map[string]interface{}{
							"automation_name":          "test-automation",
							"image_repositories":       `[{"name":"app","image":"myregistry/app","interval":"6h"}]`,
							"image_policies":           `[{"name":"app","repository":"app","policyType":"semver","range":"*"}]`,
							"git_repository_name":      "flux-system",
							"git_repository_namespace": "flux-system",
							"update_path":              "./apps/test",
							"git_branch":               "main",
							"author_name":              "Test Author",
							"author_email":             "test@example.com",
							"automation_interval":      "10m",
							"update_strategy":          "Setters",
							"commit_message_template":  "chore: update versions",
						},
					},
				},
			},
			expectError: false,
			expectedFiles: []string{
				"image-repository.yaml",
				"image-policy.yaml",
				"image-update-automation.yaml",
			},
		},
		{
			name: "externalsecret plugin",
			config: &types.AppConfig{
				AppName:   "test-app",
				Namespace: "default",
				Plugins: []plugins.PluginConfig{
					{
						PluginName: "externalsecret",
						Values: map[string]interface{}{
							"name":               "test-secret",
							"secret_store_type":  "ClusterSecretStore",
							"secret_store_name":  "vault-backend",
							"secret_key":         "secret/myapp",
							"target_secret_name": "test-target",
							"refresh_interval":   "60m",
						},
					},
				},
			},
			expectError:   false,
			expectedFiles: []string{"dependencies/external-secret-test-target.yaml"},
		},
		{
			name: "invalid plugin",
			config: &types.AppConfig{
				AppName:   "test-app",
				Namespace: "default",
				Plugins: []plugins.PluginConfig{
					{
						PluginName: "nonexistent",
						Values:     map[string]interface{}{},
					},
				},
			},
			expectError:   true,
			expectedFiles: nil,
		},
		{
			name: "plugin validation error",
			config: &types.AppConfig{
				AppName:   "test-app",
				Namespace: "default",
				Plugins: []plugins.PluginConfig{
					{
						PluginName: "imageupdate",
						Values:     map[string]interface{}{
							// Missing required automation_name
						},
					},
				},
			},
			expectError:   true,
			expectedFiles: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			appDir := filepath.Join(tempDir, tt.config.AppName+"-"+tt.name)
			if err := os.MkdirAll(appDir, 0755); err != nil {
				t.Fatalf("failed to create app directory: %v", err)
			}

			pluginFiles, err := generatePluginFiles(tt.config, appDir)

			if tt.expectError {
				if err == nil {
					t.Errorf("expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("unexpected error: %v", err)
				return
			}

			// Check expected files
			if len(pluginFiles) != len(tt.expectedFiles) {
				t.Errorf("expected %d plugin files, got %d", len(tt.expectedFiles), len(pluginFiles))
			}

			for _, expectedFile := range tt.expectedFiles {
				found := false
				for _, actualFile := range pluginFiles {
					if actualFile == expectedFile {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("expected plugin file %s not found in result", expectedFile)
				}

				// Check if file actually exists
				filePath := filepath.Join(appDir, expectedFile)
				if _, err := os.Stat(filePath); os.IsNotExist(err) {
					t.Errorf("expected file %s was not created", filePath)
				}
			}
		})
	}
}

// Test GenerateFluxStructure with imageupdate plugin
func TestGenerateFluxStructure_WithImageUpdatePlugin(t *testing.T) {
	config := &types.AppConfig{
		AppName:      "test-app",
		Namespace:    "default",
		HelmRepoName: "test-repo",
		HelmRepoURL:  "https://example.com/repo",
		ChartName:    "test-chart",
		ChartVersion: "1.0.0",
		Interval:     "5m",
		Values:       map[string]interface{}{},
		Plugins: []plugins.PluginConfig{
			{
				PluginName: "imageupdate",
				Values: map[string]interface{}{
					"automation_name":          "test-automation",
					"image_repositories":       `[{"name":"app","image":"myregistry/app","interval":"6h"}]`,
					"image_policies":           `[{"name":"app","repository":"app","policyType":"semver","range":"*"}]`,
					"git_repository_name":      "flux-system",
					"git_repository_namespace": "flux-system",
					"update_path":              "./apps/test",
					"git_branch":               "main",
					"author_name":              "Test Author",
					"author_email":             "test@example.com",
					"automation_interval":      "10m",
					"update_strategy":          "Setters",
					"commit_message_template":  "chore: update versions",
				},
			},
		},
	}

	tempDir := t.TempDir()
	originalWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get current working directory: %v", err)
	}

	// Change to temp directory for test
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("failed to change to temp directory: %v", err)
	}
	defer func() {
		if err := os.Chdir(originalWd); err != nil {
			t.Errorf("failed to restore working directory: %v", err)
		}
	}()

	err = GenerateFluxStructure(config)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Check if all expected files were created
	expectedFiles := []string{
		"test-app/dependencies/helm-repository.yaml",
		"test-app/release/helm-release.yaml",
		"test-app/release/helm-values.yaml",
		"test-app/kustomization.yaml",
		"test-app/image-repository.yaml",
		"test-app/image-policy.yaml",
		"test-app/image-update-automation.yaml",
	}

	for _, file := range expectedFiles {
		if _, err := os.Stat(file); os.IsNotExist(err) {
			t.Errorf("expected file to be created: %s", file)
		}
	}

	// Check that plugin files are added to config.PluginFiles
	expectedPluginFiles := []string{
		"image-repository.yaml",
		"image-policy.yaml",
		"image-update-automation.yaml",
	}

	if len(config.PluginFiles) != len(expectedPluginFiles) {
		t.Errorf("expected %d plugin files in config, got %d", len(expectedPluginFiles), len(config.PluginFiles))
	}

	for _, expectedFile := range expectedPluginFiles {
		found := false
		for _, actualFile := range config.PluginFiles {
			if actualFile == expectedFile {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("expected plugin file %s not found in config.PluginFiles", expectedFile)
		}
	}
}

// Test generatePluginFiles with multiple plugins
func TestGeneratePluginFiles_MultiplePlugins(t *testing.T) {
	tempDir := t.TempDir()
	originalWd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get current working directory: %v", err)
	}

	// Change to temp directory for test
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("failed to change to temp directory: %v", err)
	}
	defer func() {
		if err := os.Chdir(originalWd); err != nil {
			t.Errorf("failed to restore working directory: %v", err)
		}
	}()

	config := &types.AppConfig{
		AppName:   "test-app",
		Namespace: "default",
		Plugins: []plugins.PluginConfig{
			{
				PluginName: "imageupdate",
				Values: map[string]interface{}{
					"automation_name":          "test-automation",
					"image_repositories":       `[{"name":"app","image":"myregistry/app","interval":"6h"}]`,
					"image_policies":           `[{"name":"app","repository":"app","policyType":"semver","range":"*"}]`,
					"git_repository_name":      "flux-system",
					"git_repository_namespace": "flux-system",
					"update_path":              "./apps/test",
					"git_branch":               "main",
					"author_name":              "Test Author",
					"author_email":             "test@example.com",
					"automation_interval":      "10m",
					"update_strategy":          "Setters",
					"commit_message_template":  "chore: update versions",
				},
			},
			{
				PluginName: "externalsecret",
				Values: map[string]interface{}{
					"name":               "test-secret",
					"secret_store_type":  "ClusterSecretStore",
					"secret_store_name":  "vault-backend",
					"secret_key":         "secret/myapp",
					"target_secret_name": "test-target",
					"refresh_interval":   "60m",
				},
			},
		},
	}

	appDir := filepath.Join(tempDir, config.AppName)
	if err := os.MkdirAll(appDir, 0755); err != nil {
		t.Fatalf("failed to create app directory: %v", err)
	}

	pluginFiles, err := generatePluginFiles(config, appDir)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	// Should have 4 files total: 3 from imageupdate + 1 from externalsecret
	expectedCount := 4
	if len(pluginFiles) != expectedCount {
		t.Errorf("expected %d plugin files, got %d", expectedCount, len(pluginFiles))
	}

	// Check specific files exist
	expectedFiles := []string{
		"image-repository.yaml",
		"image-policy.yaml",
		"image-update-automation.yaml",
		"dependencies/external-secret-test-target.yaml",
	}

	for _, expectedFile := range expectedFiles {
		found := false
		for _, actualFile := range pluginFiles {
			if actualFile == expectedFile {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("expected plugin file %s not found in result", expectedFile)
		}

		// Check if file actually exists
		filePath := filepath.Join(appDir, expectedFile)
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			t.Errorf("expected file %s was not created", filePath)
		}
	}
}
