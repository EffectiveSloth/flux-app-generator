package plugins

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestNewImageUpdatePlugin(t *testing.T) {
	plugin := NewImageUpdatePlugin()

	if plugin.Name() != "imageupdate" {
		t.Errorf("expected name 'imageupdate', got '%s'", plugin.Name())
	}

	if plugin.Description() == "" {
		t.Error("description should not be empty")
	}

	variables := plugin.Variables()
	if len(variables) != 1 {
		t.Errorf("plugin should have 1 variable, got %d", len(variables))
	}

	// Check for the only required variable
	if variables[0].Name != "automation_name" {
		t.Errorf("expected variable 'automation_name', got '%s'", variables[0].Name)
	}

	if !variables[0].Required {
		t.Error("automation_name should be required")
	}

	// Test file path template
	expectedFilePath := "image-update-automation.yaml"
	if plugin.FilePath() != expectedFilePath {
		t.Errorf("expected file path '%s', got '%s'", expectedFilePath, plugin.FilePath())
	}
}

func TestImageUpdatePlugin_Variables(t *testing.T) {
	plugin := NewImageUpdatePlugin()
	variables := plugin.Variables()

	if len(variables) != 1 {
		t.Errorf("expected 1 variable, got %d", len(variables))
	}

	// Test automation_name variable
	variable := variables[0]
	if variable.Name != "automation_name" {
		t.Errorf("expected variable name 'automation_name', got '%s'", variable.Name)
	}

	if variable.Type != VariableTypeText {
		t.Errorf("automation_name variable should be text type")
	}

	if !variable.Required {
		t.Errorf("automation_name variable should be required")
	}

	if variable.Description == "" {
		t.Errorf("automation_name should have a description")
	}
}

func TestImageUpdatePlugin_Validate(t *testing.T) {
	plugin := NewImageUpdatePlugin()

	tests := []struct {
		name        string
		values      map[string]interface{}
		expectError bool
		errorText   string
	}{
		{
			name: "valid configuration with mock data",
			values: map[string]interface{}{
				"automation_name": "home-automation",
				// Mock the JSON data that would be generated by CollectCustomConfig
				"image_repositories":       `[{"name":"myapp","image":"myregistry/myapp","interval":"6h"}]`,
				"image_policies":           `[{"name":"myapp","repository":"myapp","policyType":"semver","range":"*"}]`,
				"git_repository_name":      DefaultFluxNamespace,
				"git_repository_namespace": DefaultFluxNamespace,
				"update_path":              "./apps/test",
				"git_branch":               "main",
				"author_name":              "Test Author",
				"author_email":             "test@example.com",
				"automation_interval":      "10m",
				"update_strategy":          "Setters",
				"commit_message_template":  "chore: update container versions",
			},
			expectError: false,
		},
		{
			name: "missing required automation_name",
			values: map[string]interface{}{
				"git_repository_name": DefaultFluxNamespace,
			},
			expectError: true,
			errorText:   "automation_name",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := plugin.Validate(tt.values)
			if tt.expectError {
				if err == nil {
					t.Errorf("expected error but got none")
				} else if tt.errorText != "" && !strings.Contains(err.Error(), tt.errorText) {
					t.Errorf("expected error to contain '%s', got '%s'", tt.errorText, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
			}
		})
	}
}

func TestImageUpdatePlugin_GenerateFile(t *testing.T) {
	plugin := NewImageUpdatePlugin()

	// Test with mock JSON data (since we can't run interactive forms in tests)
	values := map[string]interface{}{
		"automation_name": "home-automation",
		// Mock the JSON data that would be generated by CollectCustomConfig
		"image_repositories":       `[{"name":"myapp","image":"myregistry/myapp","interval":"6h"}]`,
		"image_policies":           `[{"name":"myapp","repository":"myapp","policyType":"semver","range":"*"}]`,
		"git_repository_name":      DefaultFluxNamespace,
		"git_repository_namespace": DefaultFluxNamespace,
		"update_path":              "./apps/test",
		"git_branch":               "main",
		"author_name":              "Test Author",
		"author_email":             "test@example.com",
		"automation_interval":      "10m",
		"update_strategy":          "Setters",
		"commit_message_template":  "chore: update container versions",
	}

	tempDir := t.TempDir()
	namespace := DefaultFluxNamespace

	err := plugin.GenerateFile(values, tempDir, namespace)
	if err != nil {
		t.Fatalf("GenerateFile failed: %v", err)
	}

	// Check if the files were created
	expectedFiles := []string{
		"image-repository.yaml",
		"image-policy.yaml",
		"image-update-automation.yaml",
	}

	for _, fileName := range expectedFiles {
		filePath := filepath.Join(tempDir, fileName)
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			t.Errorf("expected file %s was not created", fileName)
		}
	}

	// Test content of image-repository.yaml
	repoContent, err := os.ReadFile(filepath.Join(tempDir, "image-repository.yaml"))
	if err != nil {
		t.Fatalf("failed to read image-repository.yaml: %v", err)
	}

	repoStr := string(repoContent)
	if !strings.Contains(repoStr, "name: myapp") {
		t.Errorf("image-repository.yaml should contain repository name")
	}
	if !strings.Contains(repoStr, "image: myregistry/myapp") {
		t.Errorf("image-repository.yaml should contain image name")
	}

	// Test content of image-policy.yaml
	policyContent, err := os.ReadFile(filepath.Join(tempDir, "image-policy.yaml"))
	if err != nil {
		t.Fatalf("failed to read image-policy.yaml: %v", err)
	}

	policyStr := string(policyContent)
	if !strings.Contains(policyStr, "name: myapp") {
		t.Errorf("image-policy.yaml should contain policy name")
	}
	if !strings.Contains(policyStr, "semver:") {
		t.Errorf("image-policy.yaml should contain semver policy")
	}

	// Test automation file
	autoContent, err := os.ReadFile(filepath.Join(tempDir, "image-update-automation.yaml"))
	if err != nil {
		t.Fatalf("failed to read image-update-automation.yaml: %v", err)
	}

	autoStr := string(autoContent)
	if !strings.Contains(autoStr, "name: home-automation") {
		t.Errorf("image-update-automation.yaml should contain automation name")
	}
}

func TestImageUpdatePlugin_GenerateFile_EmptyArrays(t *testing.T) {
	plugin := NewImageUpdatePlugin()

	tempDir := t.TempDir()
	appDir := filepath.Join(tempDir, "test-app")

	// Create the app directory
	if err := os.MkdirAll(appDir, 0755); err != nil {
		t.Fatalf("failed to create app directory: %v", err)
	}

	values := map[string]interface{}{
		"automation_name":          "empty-test",
		"git_repository_name":      DefaultFluxNamespace,
		"git_repository_namespace": DefaultFluxNamespace,
		"update_path":              "./apps/empty-test",
		"update_strategy":          "Setters",
		"git_branch":               "main",
		"author_name":              "Test User",
		"author_email":             "test@example.com",
		"commit_message_template":  "chore: update versions",
		"automation_interval":      "5m",
		"image_repositories":       "[]",
		"image_policies":           "[]",
	}

	err := plugin.GenerateFile(values, appDir, "test-namespace")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Check that files are created even with empty arrays
	expectedFiles := []string{
		"image-repository.yaml",
		"image-policy.yaml",
		"image-update-automation.yaml",
	}

	for _, filename := range expectedFiles {
		expectedPath := filepath.Join(appDir, filename)
		if _, err := os.Stat(expectedPath); os.IsNotExist(err) {
			t.Errorf("expected file %s to be created even with empty arrays", filename)
		}
	}

	// Check image-update-automation.yaml content
	automationPath := filepath.Join(appDir, "image-update-automation.yaml")
	content, err := os.ReadFile(automationPath)
	if err != nil {
		t.Fatalf("failed to read automation file: %v", err)
	}

	contentStr := string(content)
	if !strings.Contains(contentStr, "name: empty-test") {
		t.Errorf("automation file should contain automation name")
	}
	if !strings.Contains(contentStr, "namespace: test-namespace") {
		t.Errorf("automation file should contain correct namespace")
	}
}
